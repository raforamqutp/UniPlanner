│   main.txt
│   ├───main
│   │   ├───java
│   │   │   ├───utp
│   │   │   │   ├───UNIplanner
│   │   │   │   │   UnIplannerApplication.java
│   │   │   │   │   ├───controller
│   │   │   │   │   │   CursoViewController.java
│   │   │   │   │   │   DemoController.java
│   │   │   │   │   │   HorarioController.java
│   │   │   │   │   │   SeleccionResponse.java
│   │   │   │   │   ├───model
│   │   │   │   │   │   Curso.java
│   │   │   │   │   │   CursoResponse.java
│   │   │   │   │   │   HorarioBloque.java
│   │   │   │   │   │   HorarioResponse.java
│   │   │   │   │   │   Seccion.java
│   │   │   │   │   ├───service
│   │   │   │   │   │   DemoService.java
│   │   │   │   │   │   HorarioService.java
│   │   │   │   │   │   SeleccionService.java
│   │   ├───resources
│   │   │   application.properties
│   │   │   ├───data
│   │   │   │   cursos.json
│   │   │   ├───static
│   │   │   ├───templates
│   │   │   │   cursos.html
│   │   │   │   horario.html
│   ├───test
│   │   ├───java
│   │   │   ├───utp
│   │   │   │   ├───UNIplanner
│   │   │   │   │   UnIplannerApplicationTests.java
│   │   │   │   │   ├───Controller
│   │   │   │   │   │   DemoControllerTest.java
│   │   │   │   │   ├───Service
│   │   │   │   │   │   DemoServiceTest.java

### main.txt
'''
import os

# Nombre del archivo de salida
output_file = "_Código.txt"

def generate_tree(start_path):
    """Genera una vista tipo árbol desde start_path"""
    tree_lines = []

    for root, dirs, files in os.walk(start_path):
        # Ordenar alfabéticamente
        dirs.sort()
        files.sort()
        level = root.replace(start_path, '').count(os.sep)
        indent = '│   ' * level + '├───' if level > 0 else ''
        dirname = os.path.basename(root) or os.path.abspath(root)
        if level > 0:
            tree_lines.append(f"{indent}{dirname}")
        for f in files:
            if not f.endswith(".css"):
                sub_indent = '│   ' * (level + 1)
                tree_lines.append(f"{sub_indent}{f}")
    return "\n".join(tree_lines)

def process_files(start_path):
    """Lee todos los archivos (excepto .css) y devuelve bloques formateados"""
    code_blocks = []
    for root, dirs, files in os.walk(start_path):
        for file in sorted(files):
            if file.endswith(".css"):
                continue
            file_path = os.path.join(root, file)
            relative_path = os.path.relpath(file_path, start_path).replace("\\", "/")
            try:
                with open(file_path, 'r', encoding='utf-8') as f:
                    content = f.read()
            except Exception as e:
                content = f"// Error al leer el archivo: {e}"

            block = f"### {relative_path}\n'''\n{content}\n'''\n"
            code_blocks.append(block)
    return "\n".join(code_blocks)

def main():
    start_path = os.getcwd()
    tree_output = generate_tree(start_path)
    files_output = process_files(start_path)

    with open(os.path.join(start_path, output_file), 'w', encoding='utf-8') as f:
        f.write(tree_output + "\n\n" + files_output)

    print(f"Archivo '{output_file}' generado correctamente.")

if __name__ == "__main__":
    main()

'''

### main/java/utp/UNIplanner/UnIplannerApplication.java
'''
package utp.UNIplanner;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class UnIplannerApplication {

	public static void main(String[] args) {
		SpringApplication.run(UnIplannerApplication.class, args);
	}

}

'''

### main/java/utp/UNIplanner/controller/CursoViewController.java
'''
package utp.UNIplanner.controller;

import java.util.Optional;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestParam;

import utp.UNIplanner.model.CursoResponse;
import utp.UNIplanner.service.DemoService;

@Controller
public class CursoViewController {

    private final DemoService demoService;

    public CursoViewController(DemoService demoService) {
        this.demoService = demoService;
    }

    // Mostrar todos los cursos
    @GetMapping("/cursos")
    public String verCursos(Model model) {
        model.addAttribute("titulo", "Todos los Cursos");
        model.addAttribute("cursos", demoService.getDemoCursos().getCursos());
        return "cursos";
    }

    // Mostrar cursos por ciclo
    @GetMapping("/cursos/ciclo/{ciclo}")
    public String verCursosPorCiclo(@PathVariable int ciclo, Model model) {
        model.addAttribute("titulo", "Cursos del Ciclo " + ciclo);
        model.addAttribute("cursos", demoService.getCursosPorCiclo(ciclo).getCursos());
        return "cursos";
    }

    // Mostrar cursos por nombre
    @GetMapping("/cursos/nombre/{nombre}")
    public String verCursosPorNombre(@PathVariable String nombre, Model model) {
        model.addAttribute("titulo", "Cursos que coinciden con: \"" + nombre + "\"");
        model.addAttribute("cursos", demoService.getCursosPorNombre(nombre).getCursos());
        return "cursos";
    }

    // Búsqueda avanzada con filtros
    @GetMapping("/cursos/buscar")
    public String buscarCursos(
            @RequestParam(required = false) String nombre,
            @RequestParam(required = false) Integer ciclo,
            @RequestParam(required = false) String docente,
            @RequestParam(required = false) String horario,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size,
            Model model) {

        CursoResponse response = demoService.buscarCursosPaginado(
                Optional.ofNullable(nombre),
                Optional.ofNullable(ciclo),
                Optional.ofNullable(docente),
                Optional.ofNullable(horario),
                page,
                size
        );

        model.addAttribute("titulo", "Resultados de Búsqueda");
        model.addAttribute("cursos", response.getCursos());
        model.addAttribute("page", page);
        model.addAttribute("size", size);
        return "cursos";
    }
}
'''

### main/java/utp/UNIplanner/controller/DemoController.java
'''
package utp.UNIplanner.controller;

import java.util.List;
import java.util.Optional;

import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import utp.UNIplanner.model.CursoResponse;
import utp.UNIplanner.service.DemoService;
import utp.UNIplanner.service.SeleccionService;

@RestController
@RequestMapping("/api/cursos")
public class DemoController {

    private final DemoService demoService;
    private final SeleccionService seleccionService;

    public DemoController(DemoService demoService, SeleccionService seleccionService) {
        this.demoService = demoService;
        this.seleccionService = seleccionService;
    }

    @GetMapping("/demo")
    public CursoResponse getDemo() {
        return demoService.getDemoCursos();
    }

    @GetMapping("/ciclo/{ciclo}")
    public CursoResponse getCursosPorCiclo(@PathVariable int ciclo) {
        return demoService.getCursosPorCiclo(ciclo);
    }

    @GetMapping("/nombre/{nombre}")
    public CursoResponse getCursosPorNombre(@PathVariable String nombre) {
        return demoService.getCursosPorNombre(nombre);
    }

    @GetMapping("/buscar")
    public CursoResponse buscarCursos(
            @RequestParam(required = false) String nombre,
            @RequestParam(required = false) Integer ciclo,
            @RequestParam(required = false) String docente,
            @RequestParam(required = false) String horario,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size) {
        return demoService.buscarCursosPaginado(
                Optional.ofNullable(nombre),
                Optional.ofNullable(ciclo),
                Optional.ofNullable(docente),
                Optional.ofNullable(horario),
                page,
                size
        );
    }

    @PostMapping("/seleccion")
    public SeleccionResponse seleccionar(@RequestBody List<String> codigos) {
        return seleccionService.seleccionarSecciones(codigos);
    }

    @GetMapping("/seleccion")
    public SeleccionResponse obtenerSeleccionados() {
        return seleccionService.obtenerSeleccionados();
    }

    @DeleteMapping("/seleccion")
    public void limpiarSeleccion() {
        seleccionService.limpiarSeleccion();
    }
}
'''

### main/java/utp/UNIplanner/controller/HorarioController.java
'''
package utp.UNIplanner.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;
import org.springframework.ui.Model;
import utp.UNIplanner.model.HorarioBloque;
import utp.UNIplanner.model.HorarioResponse;
import utp.UNIplanner.service.HorarioService;

import java.time.LocalTime;

@Controller
@RequestMapping("/horario")
public class HorarioController {

    private final HorarioService horarioService;

    public HorarioController(HorarioService horarioService) {
        this.horarioService = horarioService;
    }

    // Vista HTML (MVC)
    @GetMapping
    public String verHorario(Model model) {
        model.addAttribute("bloques", horarioService.obtenerHorario().getBloques());
        return "horario"; // templates/horario.html
    }

    // REST endpoints
    @GetMapping("/api")
    @ResponseBody
    public HorarioResponse obtenerHorarioJSON() {
        return horarioService.obtenerHorario();
    }

    @PostMapping("/api")
    @ResponseBody
    public void agregarBloque(@RequestBody HorarioBloque bloque) {
        horarioService.agregarBloque(bloque);
    }

    @DeleteMapping("/api")
    @ResponseBody
    public void eliminarBloque(@RequestParam String dia,
                               @RequestParam String horaInicio,
                               @RequestParam String horaFin) {
        horarioService.eliminarBloque(
                dia,
                LocalTime.parse(horaInicio),
                LocalTime.parse(horaFin)
        );
    }

    @DeleteMapping("/api/clear")
    @ResponseBody
    public void limpiarHorario() {
        horarioService.limpiar();
    }
}

'''

### main/java/utp/UNIplanner/controller/SeleccionResponse.java
'''
package utp.UNIplanner.controller;

import java.util.List;

import utp.UNIplanner.model.Seccion;

public class SeleccionResponse {
    private List<Seccion> seleccionados;
    private List<String> mensajes;
    private boolean success;

    public SeleccionResponse() {
    }

    public SeleccionResponse(List<Seccion> seleccionados, List<String> mensajes) {
        this.seleccionados = seleccionados;
        this.mensajes = mensajes;
        this.success = mensajes == null || mensajes.isEmpty();
    }

    // Getters y Setters
    public List<Seccion> getSeleccionados() {
        return seleccionados;
    }

    public void setSeleccionados(List<Seccion> seleccionados) {
        this.seleccionados = seleccionados;
    }

    public List<String> getMensajes() {
        return mensajes;
    }

    public void setMensajes(List<String> mensajes) {
        this.mensajes = mensajes;
    }

    public boolean isSuccess() {
        return success;
    }

    public void setSuccess(boolean success) {
        this.success = success;
    }
}
'''

### main/java/utp/UNIplanner/model/Curso.java
'''
package utp.UNIplanner.model;

import java.util.List;
import utp.UNIplanner.model.Seccion;

public class Curso {
    private String nombre;
    private int ciclo;
    private List<Seccion> secciones;

    public Curso() {
    }

    public Curso(String nombre, int ciclo, List<Seccion> secciones) {
        this.nombre = nombre;
        this.ciclo = ciclo;
        this.secciones = secciones;
    }

    public String getNombre() { return nombre; }
    public void setNombre(String nombre) { this.nombre = nombre; }

    public int getCiclo() { return ciclo; }
    public void setCiclo(int ciclo) { this.ciclo = ciclo; }

    public List<Seccion> getSecciones() { return secciones; }
    public void setSecciones(List<Seccion> secciones) { this.secciones = secciones; }
}
'''

### main/java/utp/UNIplanner/model/CursoResponse.java
'''
package utp.UNIplanner.model;

import java.util.List;

public class CursoResponse {
    private List<Curso> cursos;

    public CursoResponse() {
    }

    public CursoResponse(List<Curso> cursos) {
        this.cursos = cursos;
    }

    public List<Curso> getCursos() {
        return cursos;
    }

    public void setCursos(List<Curso> cursos) {
        this.cursos = cursos;
    }

	public void setMessage(String string) {
		// TODO Auto-generated method stub
		
	}
}
'''

### main/java/utp/UNIplanner/model/HorarioBloque.java
'''
package utp.UNIplanner.model;

import java.time.LocalTime;

public class HorarioBloque {
    private String dia;
    private LocalTime horaInicio;
    private LocalTime horaFin;
    private String nombre;

    public HorarioBloque() {}

    public HorarioBloque(String dia, LocalTime horaInicio, LocalTime horaFin, String nombre) {
        this.dia = dia;
        this.horaInicio = horaInicio;
        this.horaFin = horaFin;
        this.nombre = nombre;
    }

    public String getDia() { return dia; }
    public void setDia(String dia) { this.dia = dia; }

    public LocalTime getHoraInicio() { return horaInicio; }
    public void setHoraInicio(LocalTime horaInicio) { this.horaInicio = horaInicio; }

    public LocalTime getHoraFin() { return horaFin; }
    public void setHoraFin(LocalTime horaFin) { this.horaFin = horaFin; }

    public String getNombre() { return nombre; }
    public void setNombre(String nombre) { this.nombre = nombre; }
}

'''

### main/java/utp/UNIplanner/model/HorarioResponse.java
'''
package utp.UNIplanner.model;

import java.util.List;

public class HorarioResponse {
    private List<HorarioBloque> bloques;

    public HorarioResponse() {}
    public HorarioResponse(List<HorarioBloque> bloques) {
        this.bloques = bloques;
    }

    public List<HorarioBloque> getBloques() { return bloques; }
    public void setBloques(List<HorarioBloque> bloques) { this.bloques = bloques; }
}

'''

### main/java/utp/UNIplanner/model/Seccion.java
'''
package utp.UNIplanner.model;

import java.util.List;

public class Seccion {
    private String seccion;
    private String docente;
    private List<String> horario;

    public Seccion() {
    }

    public Seccion(String seccion, String docente, List<String> horario) {
        this.seccion = seccion;
        this.docente = docente;
        this.horario = horario;
    }

    public String getSeccion() { return seccion; }
    public void setSeccion(String seccion) { this.seccion = seccion; }

    public String getDocente() { return docente; }
    public void setDocente(String docente) { this.docente = docente; }

    public List<String> getHorario() { return horario; }
    public void setHorario(List<String> horario) { this.horario = horario; }
}

'''

### main/java/utp/UNIplanner/service/DemoService.java
'''
package utp.UNIplanner.service;

import org.springframework.stereotype.Service;
import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.annotation.PostConstruct;
import java.io.IOException;
import java.io.InputStream;
import java.util.*;
import java.util.stream.Collectors;

import utp.UNIplanner.model.Curso;
import utp.UNIplanner.model.CursoResponse;
import utp.UNIplanner.model.Seccion;

@Service
public class DemoService {

    private CursoResponse data;
    private List<Seccion> seleccionActual = new ArrayList<>();

    // Indexados Hashmap
    private Map<Integer, List<Curso>> indexByCiclo = new HashMap<>();
    private Map<String, List<Curso>> indexByNombre = new HashMap<>();
    private Map<String, List<Curso>> indexByDocente = new HashMap<>();

    @PostConstruct
    public void loadData() {
        ObjectMapper mapper = new ObjectMapper();
        try (InputStream is = getClass().getResourceAsStream("/data/cursos.json")) {
            this.data = mapper.readValue(is, CursoResponse.class);
            buildIndexes();
        } catch (IOException e) {
            throw new RuntimeException("Error al cargar cursos.json", e);
        }
    }

    private void buildIndexes() {
        for (Curso c : data.getCursos()) {
            // ciclo index
            indexByCiclo.computeIfAbsent(c.getCiclo(), k -> new ArrayList<>()).add(c);

            // nombre index (en lowercase)
            String keyNombre = c.getNombre().toLowerCase();
            indexByNombre.computeIfAbsent(keyNombre, k -> new ArrayList<>()).add(c);

            // docente index
            for (Seccion s : c.getSecciones()) {
                String docenteKey = s.getDocente().toLowerCase();
                indexByDocente.computeIfAbsent(docenteKey, k -> new ArrayList<>()).add(c);
            }
        }
    }

    public CursoResponse getDemoCursos() {
        return data;
    }

    public CursoResponse getCursosPorCiclo(int ciclo) {
        // Original "streaming filter"
        /*
        List<Curso> filtrados = data.getCursos().stream()
                .filter(c -> c.getCiclo() == ciclo)
                .toList();
        return new CursoResponse(filtrados);
        */
        return new CursoResponse(indexByCiclo.getOrDefault(ciclo, Collections.emptyList()));
    }

    public CursoResponse getCursosPorNombre(String nombre) {
        String nombreLower = nombre.toLowerCase();

        // Original "streaming filter"
        /*
        List<Curso> filtrados = data.getCursos().stream()
                .filter(c -> c.getNombre().toLowerCase().contains(nombreLower))
                .toList();
        return new CursoResponse(filtrados);
        */

        // Optimizado para map y coincidencia exacta
        if (indexByNombre.containsKey(nombreLower)) {
            return new CursoResponse(indexByNombre.get(nombreLower));
        } else {
            List<Curso> filtrados = data.getCursos().stream()
                    .filter(c -> c.getNombre().toLowerCase().contains(nombreLower))
                    .toList();
            return new CursoResponse(filtrados);
        }
    }

    public CursoResponse buscarCursos(
            Optional<String> nombre,
            Optional<Integer> ciclo,
            Optional<String> docente,
            Optional<String> horario) {

        // Forma original "streaming":
        /*
        List<Curso> filtrados = data.getCursos().stream()
            .filter(c -> nombre.map(n -> c.getNombre().toLowerCase().contains(n.toLowerCase())).orElse(true))
            .filter(c -> ciclo.map(ci -> c.getCiclo() == ci).orElse(true))
            .filter(c -> docente.map(d ->
                    c.getSecciones().stream()
                        .anyMatch(s -> s.getDocente().toLowerCase().contains(d.toLowerCase()))
            ).orElse(true))
            .filter(c -> horario.map(h ->
                    c.getSecciones().stream()
                        .anyMatch(s -> s.getHorario().stream().anyMatch(hr -> hr.contains(h)))
            ).orElse(true))
            .toList();
        return new CursoResponse(filtrados);
        */

        // Alternativa usando indexes preindexados
        Set<Curso> result = new HashSet<>(data.getCursos());

        if (ciclo.isPresent()) {
            result.retainAll(indexByCiclo.getOrDefault(ciclo.get(), Collections.emptyList()));
        }
        if (nombre.isPresent()) {
            String key = nombre.get().toLowerCase();
            // substring search requires fallback to scan
            Set<Curso> byName = indexByNombre.containsKey(key)
                    ? new HashSet<>(indexByNombre.get(key))
                    : data.getCursos().stream()
                          .filter(c -> c.getNombre().toLowerCase().contains(key))
                          .collect(Collectors.toSet());
            result.retainAll(byName);
        }
        if (docente.isPresent()) {
            String key = docente.get().toLowerCase();
            Set<Curso> byDoc = indexByDocente.entrySet().stream()
                    .filter(e -> e.getKey().contains(key))
                    .flatMap(e -> e.getValue().stream())
                    .collect(Collectors.toSet());
            result.retainAll(byDoc);
        }
        if (horario.isPresent()) {
            String key = horario.get();
            Set<Curso> byHorario = data.getCursos().stream()
                    .filter(c -> c.getSecciones().stream()
                            .anyMatch(s -> s.getHorario().stream().anyMatch(hr -> hr.contains(key))))
                    .collect(Collectors.toSet());
            result.retainAll(byHorario);
        }

        return new CursoResponse(new ArrayList<>(result));
    }

    public CursoResponse buscarCursosPaginado(
            Optional<String> nombre,
            Optional<Integer> ciclo,
            Optional<String> docente,
            Optional<String> horario,
            int page,
            int size) {

        List<Curso> filtrados = buscarCursos(nombre, ciclo, docente, horario).getCursos();
        int fromIndex = Math.min(page * size, filtrados.size());
        int toIndex = Math.min(fromIndex + size, filtrados.size());
        return new CursoResponse(filtrados.subList(fromIndex, toIndex));
    }
}

'''

### main/java/utp/UNIplanner/service/HorarioService.java
'''
package utp.UNIplanner.service;

import org.springframework.stereotype.Service;
import utp.UNIplanner.model.HorarioBloque;
import utp.UNIplanner.model.HorarioResponse;
import utp.UNIplanner.model.Seccion;

import java.time.LocalTime;
import java.util.*;
import java.util.concurrent.CopyOnWriteArrayList;

@Service
public class HorarioService {

    private final List<HorarioBloque> bloques = new CopyOnWriteArrayList<>();
    private final SeleccionService seleccionService;

    public HorarioService(SeleccionService seleccionService) {
        this.seleccionService = seleccionService;
        // Ya no agregamos bloques de prueba
    }

    public HorarioResponse obtenerHorario() {
        // Limpiar bloques existentes
        bloques.clear();
        
        // Obtener secciones seleccionadas y convertirlas a bloques de horario
        var seleccionResponse = seleccionService.obtenerSeleccionados();
        if (seleccionResponse.getSeleccionados() != null) {
            for (Seccion seccion : seleccionResponse.getSeleccionados()) {
                agregarSeccionAlHorario(seccion);
            }
        }
        
        return new HorarioResponse(new ArrayList<>(bloques));
    }

    private void agregarSeccionAlHorario(Seccion seccion) {
        for (String horarioStr : seccion.getHorario()) {
            HorarioBloque bloque = parseHorarioString(horarioStr, seccion);
            if (bloque != null) {
                bloques.add(bloque);
            }
        }
    }

    private HorarioBloque parseHorarioString(String horarioStr, Seccion seccion) {
        try {
            // Formato esperado: "Lunes : 08:00 - 10:00"
            String[] partes = horarioStr.split(" : ");
            if (partes.length != 2) return null;
            
            String dia = partes[0].trim();
            String[] horarios = partes[1].split(" - ");
            if (horarios.length != 2) return null;
            
            LocalTime horaInicio = LocalTime.parse(horarios[0].trim());
            LocalTime horaFin = LocalTime.parse(horarios[1].trim());
            
            String nombre = seccion.getSeccion() + " - " + seccion.getDocente();
            
            return new HorarioBloque(dia, horaInicio, horaFin, nombre);
        } catch (Exception e) {
            System.err.println("Error parseando horario: " + horarioStr);
            return null;
        }
    }

    public void agregarBloque(HorarioBloque bloque) {
        bloques.add(bloque);
    }

    public void eliminarBloque(String dia, LocalTime inicio, LocalTime fin) {
        bloques.removeIf(b -> b.getDia().equalsIgnoreCase(dia)
                && b.getHoraInicio().equals(inicio)
                && b.getHoraFin().equals(fin));
    }

    public void limpiar() {
        bloques.clear();
    }

    // Nuevo método para sincronizar con selecciones
    public void sincronizarConSelecciones() {
        obtenerHorario(); // Esto actualizará los bloques
    }
}
'''

### main/java/utp/UNIplanner/service/SeleccionService.java
'''
package utp.UNIplanner.service;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Optional;
import java.util.concurrent.CopyOnWriteArrayList;

import org.springframework.stereotype.Service;

import utp.UNIplanner.controller.SeleccionResponse;
import utp.UNIplanner.model.Seccion;

@Service
public class SeleccionService {

    private final DemoService demoService;
    private final List<Seccion> seleccionados = new CopyOnWriteArrayList<>();

    public SeleccionService(DemoService demoService) {
        this.demoService = demoService;
    }

    // Seleccionar secciones por sus códigos
    public SeleccionResponse seleccionarSecciones(List<String> codigos) {
        List<Seccion> nuevas = new ArrayList<>();
        List<String> mensajes = new ArrayList<>();

        // Buscar secciones en los cursos existentes
        for (String codigo : codigos) {
            Optional<Seccion> seccion = demoService.getDemoCursos().getCursos().stream()
                    .flatMap(c -> c.getSecciones().stream())
                    .filter(s -> s.getSeccion().equals(codigo))
                    .findFirst();

            if (seccion.isPresent()) {
                nuevas.add(seccion.get());
            } else {
                mensajes.add("No se encontró la sección con código: " + codigo);
            }
        }

        // Detectar choques de horario entre los ya seleccionados + nuevos
        List<Seccion> total = new ArrayList<>(seleccionados);
        total.addAll(nuevas);
        mensajes.addAll(detectarChoques(total));

        // Agregar igualmente las secciones nuevas a seleccionados
        seleccionados.addAll(nuevas);

        return new SeleccionResponse(new ArrayList<>(seleccionados), mensajes);
    }

    // Retorna todos los seleccionados actuales
    public SeleccionResponse obtenerSeleccionados() {
        return new SeleccionResponse(new ArrayList<>(seleccionados), Collections.emptyList());
    }

    // Limpia la selección
    public void limpiarSeleccion() {
        seleccionados.clear();
    }

    // Detección simple de choques basada en igualdad exacta de cadenas de horario
    private List<String> detectarChoques(List<Seccion> secciones) {
        List<String> conflictos = new ArrayList<>();

        for (int i = 0; i < secciones.size(); i++) {
            for (int j = i + 1; j < secciones.size(); j++) {
                Seccion a = secciones.get(i);
                Seccion b = secciones.get(j);
                for (String h1 : a.getHorario()) {
                    for (String h2 : b.getHorario()) {
                        if (h1.equals(h2)) {
                            conflictos.add("Choque entre sección " +
                                    a.getSeccion() +
                                    " y sección " +
                                    b.getSeccion() +
                                    " en horario: " + h1);
                        }
                    }
                }
            }
        }
        return conflictos;
    }
}
'''

### main/resources/application.properties
'''
spring.application.name=UNIplanner
server.port=8420
'''

### main/resources/data/cursos.json
'''
{
  "cursos": [
    {
      "nombre": "CURSO INTEGRADOR I: SISTEMAS - SOFTWARE",
      "ciclo": 6,
      "secciones": [
        {
          "seccion": "11335",
          "docente": "GONZALES SAJI,FREDDY ORLANDO",
          "horario": [
            "Martes : 20:15 - 21:45",
            "Viernes : 20:15 - 21:45"
          ]
        },
        {
          "seccion": "11288",
          "docente": "GONZALES SAJI,FREDDY ORLANDO",
          "horario": [
            "Martes : 14:00 - 15:30",
            "Viernes : 14:00 - 15:30"
          ]
        },
        {
          "seccion": "7272",
          "docente": "NIETO VALENCIA,RENE ALONSO",
          "horario": [
            "Martes : 08:45 - 10:15",
            "Jueves : 08:45 - 10:15"
          ]
        }
      ]
    },
    {
      "nombre": "HERRAMIENTAS DE DESARROLLO",
      "ciclo": 7,
      "secciones": [
        {
          "seccion": "12242",
          "docente": "RAMIREZ TICONA,JUAN",
          "horario": [
            "Miercoles : 12:15 - 13:45",
            "Sabado : 12:15 - 13:45"
          ]
        }
      ]
    },
    {
      "nombre": "DESARROLLO WEB INTEGRADO",
      "ciclo": 7,
      "secciones": [
        {
          "seccion": "12240",
          "docente": "VALENCIA GALLEGOS,OMAR JULIO",
          "horario": [
            "Miercoles : 14:30 - 16:45"
          ]
        }
      ]
    },
    {
      "nombre": "DISEÑO DE PRODUCTOS Y SERVICIOS",
      "ciclo": 7,
      "secciones": [
        {
          "seccion": "12292",
          "docente": "MALDONADO QUISPE,PERCY",
          "horario": [
            "Sabado : 17:00 - 19:15"
          ]
        },
        {
          "seccion": "12279",
          "docente": "FERNANDEZ CATALAN,JULIO EDZEL",
          "horario": [
            "Viernes : 14:30 - 16:45"
          ]
        },
        {
          "seccion": "12262",
          "docente": "MALDONADO QUISPE,PERCY",
          "horario": [
            "Miercoles : 07:00 - 09:15"
          ]
        },
        {
          "seccion": "12243",
          "docente": "MALDONADO QUISPE,PERCY",
          "horario": [
            "Jueves : 07:00 - 09:15"
          ]
        }
      ]
    },
    {
      "nombre": "DISEÑO E IMPLEMENTACIÓN DE ARQUITECTURA EMPRESARIAL",
      "ciclo": 8,
      "secciones": [
        {
          "seccion": "12893",
          "docente": "CHAVEZ CUARITE,DUILIO ANDRE",
          "horario": [
            "Lunes : 17:00 - 18:30",
            "Jueves : 17:00 - 18:30"
          ]
        },
        {
          "seccion": "12881",
          "docente": "BEGAZO ARENAS,OSCAR ALFREDO",
          "horario": [
            "Martes : 20:15 - 21:45",
            "Viernes : 20:15 - 21:45"
          ]
        }
      ]
    },
    {
      "nombre": "GESTIÓN DEL SERVICIO TI",
      "ciclo": 8,
      "secciones": [
        {
          "seccion": "12882",
          "docente": "CALLO AGUILAR,ALEJANDRA CRISTINA",
          "horario": [
            "Lunes : 17:00 - 18:30",
            "Jueves : 17:00 - 18:30"
          ]
        },
        {
          "seccion": "12855",
          "docente": "GÁLVEZ GÁLVEZ,DAVID ARTHUR",
          "horario": [
            "Martes : 10:30 - 12:00",
            "Viernes : 10:30 - 12:00"
          ]
        }
      ]
    },
    {
      "nombre": "NEGOCIACIÓN Y NARRATIVA",
      "ciclo": 8,
      "secciones": [
        {
          "seccion": "12897",
          "docente": "ESCALANTE ARENAS,MARIA ANGELA",
          "horario": [
            "Viernes : 17:00 - 18:30"
          ]
        },
        {
          "seccion": "12892",
          "docente": "ESCALANTE ARENAS,MARIA ANGELA",
          "horario": [
            "Miercoles : 17:00 - 18:30"
          ]
        },
        {
          "seccion": "12879",
          "docente": "ESCALANTE ARENAS,MARIA ANGELA",
          "horario": [
            "Martes : 17:00 - 18:30"
          ]
        },
        {
          "seccion": "12860",
          "docente": "VIZA CALISAYA,ENZO ARTURO",
          "horario": [
            "Miercoles : 14:00 - 15:30"
          ]
        },
        {
          "seccion": "12859",
          "docente": "ESCALANTE ARENAS,MARIA ANGELA",
          "horario": [
            "Martes : 14:00 - 15:30"
          ]
        },
        {
          "seccion": "12858",
          "docente": "ESCALANTE ARENAS,MARIA ANGELA",
          "horario": [
            "Viernes : 14:00 - 15:30"
          ]
        },
        {
          "seccion": "12853",
          "docente": "ESCALANTE ARENAS,MARIA ANGELA",
          "horario": [
            "Lunes : 14:00 - 15:30"
          ]
        }
      ]
    },
    {
      "nombre": "INNOVACIÓN Y TRANSFORMACIÓN DIGITAL",
      "ciclo": 8,
      "secciones": [
        {
          "seccion": "12894",
          "docente": "ALFARO CASAS,LUIS ALBERTO",
          "horario": [
            "Miercoles : 20:15 - 21:45",
            "Viernes : 20:15 - 21:45"
          ]
        },
        {
          "seccion": "12883",
          "docente": "NIETO VALENCIA,RENE ALONSO",
          "horario": [
            "Miercoles : 17:00 - 18:30",
            "Sabado : 17:00 - 18:30"
          ]
        }
      ]
    }
  ]
}
'''

### main/resources/templates/cursos.html
'''
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org" lang="es">
<head>
    <meta charset="UTF-8">
    <title th:text="${titulo}">Cursos</title>
    <style>
        body {
            font-family: "Segoe UI", Roboto, sans-serif;
            background-color: #f7f9fc;
            margin: 0;
            padding: 0;
        }

        nav {
            display: flex;
            justify-content: space-around;
            align-items: center;
            background-color: #1e3a8a;
            padding: 0.8rem;
            flex-wrap: wrap;
        }

        nav a {
            color: white;
            text-decoration: none;
            font-size: 0.95rem;
            font-weight: 500;
            padding: 0.5rem 0.8rem;
            transition: background 0.2s ease;
            border-radius: 6px;
        }

        nav a:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        header {
            text-align: center;
            padding: 1rem;
            color: #1e3a8a;
        }

        h1 {
            margin: 0;
            font-size: 1.8rem;
        }

        .container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 1.5rem;
            padding: 2rem;
        }

        .card {
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            padding: 1.5rem;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .card:hover {
            transform: translateY(-4px);
            box-shadow: 0 6px 14px rgba(0,0,0,0.15);
        }

        .curso-nombre {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: #1e3a8a;
        }

        .ciclo {
            font-size: 0.9rem;
            color: #555;
            margin-bottom: 1rem;
        }

        .seccion {
            margin-bottom: 1rem;
            padding: 0.5rem;
            border-left: 3px solid #1e3a8a;
            background-color: #f1f5f9;
            border-radius: 6px;
            position: relative;
        }

        .seccion-checkbox {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            transform: scale(1.2);
        }

        .seccion.selected {
            border-left-color: #10b981;
            background-color: #d1fae5;
        }

        .docente {
            font-weight: 500;
            color: #333;
            margin-bottom: 0.3rem;
        }

        .horario {
            font-size: 0.85rem;
            color: #555;
            margin: 0;
        }

        .actions {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            display: flex;
            gap: 1rem;
        }

        .btn {
            padding: 0.75rem 1.5rem;
            background-color: #1e3a8a;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            transition: background-color 0.2s;
        }

        .btn:hover {
            background-color: #1e40af;
        }

        .btn-success {
            background-color: #10b981;
        }

        .btn-success:hover {
            background-color: #059669;
        }

        /* Responsive */
        @media (max-width: 600px) {
            nav {
                flex-direction: column;
                align-items: stretch;
            }
            nav a {
                text-align: center;
                padding: 0.8rem;
                width: 100%;
            }
            .actions {
                position: static;
                justify-content: center;
                margin: 1rem;
            }
        }
    </style>
</head>
<body>

	<nav>
	    <a th:href="@{/cursos}">Todos</a>
	    <a th:href="@{/cursos/ciclo/6}">Ciclo 6</a>
	    <a th:href="@{/cursos/ciclo/7}">Ciclo 7</a>
	    <a th:href="@{/cursos/ciclo/8}">Ciclo 8</a>
	    <a th:href="@{/horario}">Ver Horario</a>
	</nav>

    <header>
        <h1 th:text="${titulo}">Cursos</h1>
    </header>
    
    <form th:action="@{/cursos/buscar}" method="get" style="padding:1rem; background:#f1f5f9; border-radius:8px; margin:1rem;">
    	<input type="text" name="nombre" placeholder="Nombre del curso">
    	<input type="number" name="ciclo" placeholder="Ciclo">
    	<input type="text" name="docente" placeholder="Docente">
    	<input type="text" name="horario" placeholder="Horario">
    	<button type="submit">Buscar</button>
	</form>

    <div class="container">
        <div class="card" th:each="curso : ${cursos}">
            <div class="curso-nombre" th:text="${curso.nombre}"></div>
            <div class="ciclo">Ciclo: <span th:text="${curso.ciclo}"></span></div>

            <div class="seccion" th:each="seccion : ${curso.secciones}">
                <input type="checkbox" 
                       class="seccion-checkbox"
                       th:value="${seccion.seccion}"
                       th:data-horario="${#strings.listJoin(seccion.horario, '|')}"
                       th:data-nombre="${curso.nombre + ' - Sección ' + seccion.seccion}"
                       onchange="toggleSeccion(this)">
                <div class="docente">Sección: <span th:text="${seccion.seccion}"></span> - <span th:text="${seccion.docente}"></span></div>
                <p class="horario" th:each="h : ${seccion.horario}" th:text="${h}"></p>
            </div>
        </div>
    </div>

    <div class="actions">
        <button class="btn" onclick="verHorario()">Ver Horario Actual</button>
        <button class="btn btn-success" onclick="actualizarHorario()">Actualizar Horario</button>
    </div>

    <script>
        let seccionesSeleccionadas = new Set();

        function toggleSeccion(checkbox) {
            const seccionDiv = checkbox.parentElement;
            const seccionData = {
                codigo: checkbox.value,
                horarios: checkbox.getAttribute('data-horario').split('|'),
                nombre: checkbox.getAttribute('data-nombre')
            };

            if (checkbox.checked) {
                seccionDiv.classList.add('selected');
                seccionesSeleccionadas.add(seccionData);
            } else {
                seccionDiv.classList.remove('selected');
                seccionesSeleccionadas.delete(seccionData);
            }
        }

        function actualizarHorario() {
            const codigos = Array.from(seccionesSeleccionadas).map(s => s.codigo);
            
            fetch('/api/cursos/seleccion', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(codigos)
            })
            .then(response => response.json())
            .then(data => {
                if (data.mensajes && data.mensajes.length > 0) {
                    alert('Advertencias: ' + data.mensajes.join('\n'));
                }
                alert('Horario actualizado correctamente!');
                // Redirigir al horario
                window.location.href = '/horario';
            })
            .catch(error => {
                console.error('Error:', error);
                alert('Error al actualizar el horario');
            });
        }

        function verHorario() {
            window.location.href = '/horario';
        }

        // Cargar selecciones existentes al cargar la página
        document.addEventListener('DOMContentLoaded', function() {
            fetch('/api/cursos/seleccion')
                .then(response => response.json())
                .then(data => {
                    if (data.seleccionados) {
                        data.seleccionados.forEach(seccion => {
                            const checkbox = document.querySelector(`input[value="${seccion.seccion}"]`);
                            if (checkbox) {
                                checkbox.checked = true;
                                checkbox.parentElement.classList.add('selected');
                                // Reconstruir el objeto seccionData
                                const seccionData = {
                                    codigo: seccion.seccion,
                                    horarios: seccion.horario,
                                    nombre: seccion.seccion // Podríamos mejorar esto
                                };
                                seccionesSeleccionadas.add(seccionData);
                            }
                        });
                    }
                });
        });
    </script>
</body>
</html>
'''

### main/resources/templates/horario.html
'''
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Horario - UNIplanner</title>
<style>
body {
  font-family: "Segoe UI", Roboto, sans-serif;
  background-color: #f7f9fc;
  margin: 0;
  padding: 0;
}

nav {
  display: flex;
  justify-content: space-around;
  align-items: center;
  background-color: #1e3a8a;
  padding: 0.8rem;
  flex-wrap: wrap;
}

nav a {
  color: white;
  text-decoration: none;
  font-size: 0.95rem;
  font-weight: 500;
  padding: 0.5rem 0.8rem;
  transition: background 0.2s ease;
  border-radius: 6px;
}

nav a:hover {
  background: rgba(255, 255, 255, 0.15);
}

.header {
  text-align: center;
  padding: 1rem;
  color: #1e3a8a;
}

.actions {
  text-align: center;
  margin: 1rem;
}

.btn {
  padding: 0.75rem 1.5rem;
  background-color: #ef4444;
  color: white;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  font-size: 1rem;
  transition: background-color 0.2s;
  margin: 0 0.5rem;
}

.btn:hover {
  background-color: #dc2626;
}

.btn-success {
  background-color: #10b981;
}

.btn-success:hover {
  background-color: #059669;
}

.schedule-container {
  max-width: 100%;
  overflow-x: auto;
  background-color: white;
  border-radius: 8px;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
  padding: 20px;
  margin: 1rem;
}

.schedule-grid {
  display: grid;
  grid-template-columns: 120px repeat(7, 1fr);
  gap: 1px;
  background-color: #e9ecef;
  border: 1px solid #e9ecef;
}

.schedule-corner, 
.schedule-header, 
.schedule-time, 
.schedule-cell {
  padding: 10px;
  background-color: white;
}

.schedule-header {
  font-weight: bold;
  text-align: center;
  background-color: #f8f9fa;
  position: sticky;
  top: 0;
}

.schedule-time {
  font-size: 0.85rem;
  color: #495057;
  border-right: 1px solid #e9ecef;
  display: flex;
  align-items: center;
}

.schedule-cell {
  position: relative;
  min-height: 40px;
  transition: background-color 0.2s;
}

.schedule-cell:hover {
  background-color: #f8f9fa;
}

.bold-hour {
  font-weight: bold;
}

.course-block {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  border-radius: 4px;
  padding: 4px 8px;
  margin: 1px;
  font-size: 0.75rem;
  border-left: 3px solid #4f46e5;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.course-block:hover {
  transform: scale(1.02);
  box-shadow: 0 2px 4px rgba(0,0,0,0.2);
}

@media (max-width: 768px) {
  .schedule-grid {
    grid-template-columns: 80px repeat(7, 1fr);
    font-size: 0.8rem;
  }
  
  .schedule-corner, 
  .schedule-header, 
  .schedule-time, 
  .schedule-cell {
    padding: 5px;
  }
}
</style>
</head>
<body>

<nav>
    <a th:href="@{/cursos}">Volver a Cursos</a>
    <a th:href="@{/horario}">Actualizar Horario</a>
</nav>

<div class="header">
    <h1>Mi Horario</h1>
</div>

<div class="actions">
    <button class="btn" onclick="limpiarHorario()">Limpiar Horario</button>
    <button class="btn btn-success" onclick="actualizarDesdeBackend()">Actualizar desde Servidor</button>
</div>

<div class="schedule-container">
    <div class="schedule-grid" id="scheduleGrid">
        <!-- El contenido se generará dinámicamente con JavaScript -->
    </div>
</div>

<script>
class HorarioManager {
  constructor() {
    this.dias = ["Lunes", "Martes", "Miércoles", "Jueves", "Viernes", "Sábado", "Domingo"];
    this.horas = this.generarHoras();
    this.grid = document.getElementById('scheduleGrid');
    this.crearEstructuraBase();
  }

  generarHoras() {
    const horas = [];
    for (let h = 7; h <= 22; h++) {
      for (let m = 0; m < 60; m += 30) {
        const horaInicio = `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`;
        const horaFin = m === 30 ? `${h}:30` : `${h + 1}:00`;
        horas.push({
          inicio: horaInicio,
          fin: `${(m === 30 ? h : h + 1).toString().padStart(2, '0')}:${m === 30 ? '00' : '30'}`
        });
      }
    }
    return horas;
  }

  crearEstructuraBase() {
    // Limpiar grid
    this.grid.innerHTML = '';

    // Encabezados
    this.grid.appendChild(this.crearCelda('schedule-corner', ''));
    this.dias.forEach(dia => {
      this.grid.appendChild(this.crearCelda('schedule-header', dia));
    });

    // Filas de horarios
    this.horas.forEach((hora, index) => {
      const esHoraCompleta = hora.inicio.endsWith(':00');
      const claseHora = esHoraCompleta ? 'schedule-time bold-hour' : 'schedule-time';
      
      this.grid.appendChild(this.crearCelda(claseHora, `${hora.inicio} - ${hora.fin}`));
      
      // Celdas para cada día
      this.dias.forEach(() => {
        this.grid.appendChild(this.crearCelda('schedule-cell', ''));
      });
    });
  }

  crearCelda(clase, contenido) {
    const celda = document.createElement('div');
    celda.className = clase;
    celda.textContent = contenido;
    return celda;
  }

  obtenerIndiceCelda(dia, horaInicio) {
    const diaIndex = this.dias.indexOf(dia);
    if (diaIndex === -1) return -1;

    const horaIndex = this.horas.findIndex(h => h.inicio === horaInicio);
    if (horaIndex === -1) return -1;

    // Fórmula: 1 (header) + (horaIndex * 8) + diaIndex + 1
    return 1 + (horaIndex * 8) + diaIndex + 1;
  }

  marcarBloque(bloque) {
    const inicioIndex = this.horas.findIndex(h => h.inicio === bloque.horaInicio);
    const finIndex = this.horas.findIndex(h => h.inicio === bloque.horaFin);
    
    if (inicioIndex === -1 || finIndex === -1) return;

    const duracion = finIndex - inicioIndex;
    
    for (let i = 0; i <= duracion; i++) {
      const celdaIndex = this.obtenerIndiceCelda(bloque.dia, this.horas[inicioIndex + i].inicio);
      if (celdaIndex !== -1) {
        const celda = this.grid.children[celdaIndex];
        this.limpiarCelda(celda);
        
        if (i === 0) {
          // Solo mostrar texto en la primera celda del bloque
          const bloqueElement = document.createElement('div');
          bloqueElement.className = 'course-block';
          bloqueElement.textContent = bloque.nombre;
          bloqueElement.title = `${bloque.nombre}\n${bloque.horaInicio} - ${bloque.horaFin}`;
          celda.appendChild(bloqueElement);
        } else {
          // Para las demás celdas, solo color de fondo
          celda.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
          celda.style.borderLeft = '3px solid #4f46e5';
        }
      }
    }
  }

  limpiarCelda(celda) {
    celda.innerHTML = '';
    celda.style.background = '';
    celda.style.borderLeft = '';
  }

  limpiarHorario() {
    this.crearEstructuraBase();
  }

  cargarBloques(bloques) {
    this.limpiarHorario();
    bloques.forEach(bloque => {
      // Convertir formato de tiempo si es necesario
      const bloqueFormateado = {
        ...bloque,
        horaInicio: this.formatearHora(bloque.horaInicio),
        horaFin: this.formatearHora(bloque.horaFin)
      };
      this.marcarBloque(bloqueFormateado);
    });
  }

  formatearHora(hora) {
    // Convertir "08:00" a "08:00", "8:00" a "08:00"
    if (hora.includes(":")) {
      const [horas, minutos] = hora.split(':');
      return `${horas.padStart(2, '0')}:${minutos.padStart(2, '0')}`;
    }
    return hora;
  }
}

// Instancia global del manager
let horarioManager;

document.addEventListener('DOMContentLoaded', function() {
  horarioManager = new HorarioManager();
  actualizarDesdeBackend();
});

function actualizarDesdeBackend() {
  fetch('/horario/api')
    .then(response => response.json())
    .then(data => {
      if (data.bloques && data.bloques.length > 0) {
        horarioManager.cargarBloques(data.bloques);
      } else {
        alert('No hay cursos seleccionados en el horario');
      }
    })
    .catch(error => {
      console.error('Error:', error);
      alert('Error al cargar el horario');
    });
}

function limpiarHorario() {
  if (confirm('¿Estás seguro de que quieres limpiar todo el horario?')) {
    fetch('/horario/api/clear', {
      method: 'DELETE'
    })
    .then(() => {
      horarioManager.limpiarHorario();
      alert('Horario limpiado correctamente');
    })
    .catch(error => {
      console.error('Error:', error);
      alert('Error al limpiar el horario');
    });
  }
}
</script>
</body>
</html>
'''

### test/java/utp/UNIplanner/UnIplannerApplicationTests.java
'''
package utp.UNIplanner;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class UnIplannerApplicationTests {

	@Test
	void contextLoads() {
	}

}

'''

### test/java/utp/UNIplanner/Controller/DemoControllerTest.java
'''
package utp.UNIplanner.Controller;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.test.web.servlet.MockMvc;

import utp.UNIplanner.controller.DemoController;
import utp.UNIplanner.model.CursoResponse;
import utp.UNIplanner.service.DemoService;
import utp.UNIplanner.service.SeleccionService;

import java.util.Optional;

import static org.mockito.Mockito.when;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

@WebMvcTest(DemoController.class)
class DemoControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @MockBean
    private DemoService demoService;

    @MockBean
    private SeleccionService seleccionService;

    @Test
    void testGetCursosPorNombre() throws Exception {
        CursoResponse mockResponse = new CursoResponse();
        mockResponse.setMessage("Found curso");
        when(demoService.getCursosPorNombre("math")).thenReturn(mockResponse);

        mockMvc.perform(get("/api/cursos/nombre/math"))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.message").value("Found curso"));
    }

    @Test
    void testBuscarCursosByCiclo() throws Exception {
        CursoResponse mockResponse = new CursoResponse();
        mockResponse.setMessage("Filtered by ciclo");
        when(demoService.buscarCursosPaginado(
                Optional.empty(),
                Optional.of(3),
                Optional.empty(),
                Optional.empty(),
                0,
                10
        )).thenReturn(mockResponse);

        mockMvc.perform(get("/api/cursos/buscar")
                        .param("ciclo", "3"))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.message").value("Filtered by ciclo"));
    }

    @Test
    void testBuscarCursosByNombreAndDocente() throws Exception {
        CursoResponse mockResponse = new CursoResponse();
        mockResponse.setMessage("Filtered by nombre and docente");
        when(demoService.buscarCursosPaginado(
                Optional.of("algebra"),
                Optional.empty(),
                Optional.of("Smith"),
                Optional.empty(),
                0,
                10
        )).thenReturn(mockResponse);

        mockMvc.perform(get("/api/cursos/buscar")
                        .param("nombre", "algebra")
                        .param("docente", "Smith"))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.message").value("Filtered by nombre and docente"));
    }

    @Test
    void testBuscarCursosWithPagination() throws Exception {
        CursoResponse mockResponse = new CursoResponse();
        mockResponse.setMessage("Paged result");
        when(demoService.buscarCursosPaginado(
                Optional.empty(),
                Optional.empty(),
                Optional.empty(),
                Optional.empty(),
                2,
                5
        )).thenReturn(mockResponse);

        mockMvc.perform(get("/api/cursos/buscar")
                        .param("page", "2")
                        .param("size", "5"))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.message").value("Paged result"));
    }
}

'''

### test/java/utp/UNIplanner/Service/DemoServiceTest.java
'''
package utp.UNIplanner.Service;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;
import utp.UNIplanner.model.Curso;
import utp.UNIplanner.model.CursoResponse;
import utp.UNIplanner.service.DemoService;

import java.util.List;
import java.util.Optional;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Pruebas unitarias para la clase DemoService, que simula la carga y búsqueda de cursos
 * desde un archivo JSON en la aplicación UNIplanner.
 *
 * Estas pruebas verifican que:
 * - Se carguen correctamente los cursos desde el archivo.
 * - Se puedan filtrar cursos por ciclo, nombre, docente y horario.
 * - Funcione la búsqueda combinada y la paginación de resultados.
 *
 * Ayudan a asegurar que las funciones principales del servicio trabajen como se espera.
 */

@SpringBootTest
class DemoServiceTest {

    private DemoService demoService;

    @BeforeEach
    void setUp() {
        demoService = new DemoService();
        demoService.loadData(); // carga cursos.json y construye los índices
    }

    @Test
    void testLoadData() {
        CursoResponse response = demoService.getDemoCursos();
        assertNotNull(response);
        assertFalse(response.getCursos().isEmpty(), "Debe cargar cursos.json");
    }

    @Test
    void testGetCursosPorCiclo() {
        CursoResponse response = demoService.getCursosPorCiclo(1);
        for (Curso c : response.getCursos()) {
            assertEquals(1, c.getCiclo(), "Todos deben pertenecer al ciclo 1");
        }
    }

    @Test
    void testGetCursosPorNombreExacto() {
        // asume que existe un curso llamado "Integrador"
        CursoResponse response = demoService.getCursosPorNombre("Integrador");
        assertFalse(response.getCursos().isEmpty());
        assertTrue(response.getCursos().stream()
                .anyMatch(c -> c.getNombre().equalsIgnoreCase("Integrador")));
    }

    @Test
    void testGetCursosPorNombreSubstring() {
        CursoResponse response = demoService.getCursosPorNombre("inte");
        assertFalse(response.getCursos().isEmpty());
        assertTrue(response.getCursos().stream()
                .anyMatch(c -> c.getNombre().toLowerCase().contains("inte")));
    }

    @Test
    void testBuscarCursosPorDocente() {
        CursoResponse response = demoService.buscarCursos(
                Optional.empty(),
                Optional.empty(),
                Optional.of("García"),
                Optional.empty()
        );
        assertTrue(response.getCursos().stream()
                .allMatch(c -> c.getSecciones().stream()
                        .anyMatch(s -> s.getDocente().toLowerCase().contains("tico"))));
    }

    @Test
    void testBuscarCursosPorHorario() {
        CursoResponse response = demoService.buscarCursos(
                Optional.empty(),
                Optional.empty(),
                Optional.empty(),
                Optional.of("08:00")
        );
        assertTrue(response.getCursos().stream()
                .allMatch(c -> c.getSecciones().stream()
                        .anyMatch(s -> s.getHorario().stream().anyMatch(h -> h.contains("08:00")))));
    }

    @Test
    void testBuscarCursosCombinado() {
        CursoResponse response = demoService.buscarCursos(
                Optional.of("inte"),
                Optional.of(1),
                Optional.of("Ticona"),
                Optional.empty()
        );
        for (Curso c : response.getCursos()) {
            assertEquals(1, c.getCiclo());
            assertTrue(c.getNombre().toLowerCase().contains("inte"));
        }
    }

    @Test
    void testBuscarCursosPaginado() {
        CursoResponse response = demoService.buscarCursosPaginado(
                Optional.empty(),
                Optional.empty(),
                Optional.empty(),
                Optional.empty(),
                0,
                2
        );
        assertTrue(response.getCursos().size() <= 2);
    }
}

'''
