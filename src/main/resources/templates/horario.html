<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
<meta charset="UTF-8">
<title>Horario - UNIplanner</title>
<style>
body { font-family: "Segoe UI", Roboto, sans-serif; background:#f7f9fc; margin:0; padding:0; }
nav{display:flex;justify-content:space-around;align-items:center;background:#1e3a8a;padding:.8rem;}
nav a{color:#fff;text-decoration:none;padding:.5rem .8rem;border-radius:6px}
.header{ text-align:center;padding:1rem;color:#1e3a8a }
.actions{ text-align:center;margin:1rem }
.btn{ padding:.75rem 1.5rem;background:#ef4444;color:#fff;border:none;border-radius:8px;cursor:pointer;margin:0 .5rem }
.btn-success{ background:#10b981 }
.schedule-container{ max-width:100%; overflow-x:auto;background:#fff;border-radius:8px; padding:20px;margin:1rem; box-shadow:0 2px 10px rgba(0,0,0,.1) }
.schedule-grid{ display:grid; grid-template-columns:120px repeat(7,1fr); gap:1px; background:#e9ecef; border:1px solid #e9ecef; position:relative; }
.schedule-corner,.schedule-header,.schedule-time,.schedule-cell{ padding:10px;background:#fff }
.schedule-header{ font-weight:bold;text-align:center;background:#f8f9fa; position:sticky; top:0 }
.schedule-time{ font-size:.85rem;color:#495057;border-right:1px solid #e9ecef; display:flex;align-items:center }
.schedule-cell{ position:relative; min-height:30px; transition:background-color .15s }
.schedule-cell:hover{ background:#f8f9fa }
.bold-hour{ font-weight:bold }
.course-block{ 
    background:linear-gradient(135deg,#667eea 0%,#764ba2 100%); 
    color:#fff; 
    border-radius:4px; 
    padding:6px; 
    font-size:15; 
    border-left:4px solid #4f46e5; 
    position:absolute; 
    left:2px; 
    right:2px; 
    top:2px; 
    bottom:2px; 
    overflow:hidden; 
    z-index:2;
    box-sizing:border-box;
}
.course-title{ font-weight:bold; margin-bottom:2px; font-size:15; line-height:1.1; }
.course-info{ font-size:10; opacity:.9; line-height:1.1; }
.course-time{ font-size:8; opacity:.8; margin-top:2px; }
.debug-info{ background:#f0f0f0; padding:10px; margin:10px; border-radius:5px; font-family:monospace; font-size:.8rem; }
@media (max-width:768px){ 
    .schedule-grid{ grid-template-columns:80px repeat(7,1fr); font-size:.8rem } 
    .schedule-corner,.schedule-header,.schedule-time,.schedule-cell{ padding:5px } 
}
</style>
</head>
<body>
<nav>
  <a th:href="@{/cursos}">Volver a Cursos</a>
  <a th:href="@{/horario}">Actualizar Horario</a>
</nav>

<div class="header">
  <h1>Mi Horario</h1>
  <p id="statusMessage">Cargando horario...</p>
</div>

<div class="actions">
  <button class="btn" onclick="limpiarHorario()">Limpiar Horario</button>
  <button class="btn btn-success" onclick="actualizarDesdeBackend()">Actualizar desde Servidor</button>
  <button class="btn" onclick="toggleDebug()">Mostrar Debug</button>
</div>

<div id="debugPanel" class="debug-info" style="display:none;">
  <h3>Información de Debug</h3>
  <div id="debugContent"></div>
</div>

<div class="schedule-container">
  <div class="schedule-grid" id="scheduleGrid"></div>
</div>

<script>
class HorarioManager {
  constructor() {
    this.daysCanonical = ["Lunes","Martes","Miercoles","Jueves","Viernes","Sabado","Domingo"];
    this.grid = document.getElementById('scheduleGrid');
    this.times = this._generarSlots("07:00", "22:00", 30);
    this.debugContent = document.getElementById('debugContent');
    this._buildGrid();
    this._loadFromApi();
  }

  _log(...args){ 
    console.log(...args); 
    if(this.debugContent) {
      this.debugContent.innerHTML += args.join(' ') + '<br>';
    }
  }

  _generarSlots(start, end, stepMin){
    const parse = t=>{ 
        const [h,m]=t.split(':').map(Number); 
        return h*60+m; 
    };
    const pad = n => String(n).padStart(2,'0');
    const slots=[];
    let cur = parse(start);
    const endM = parse(end);
    while(cur < endM){
      const next = cur + stepMin;
      const hh = pad(Math.floor(cur/60)); 
      const mm = pad(cur%60);
      const nh = pad(Math.floor(next/60)); 
      const nm = pad(next%60);
      slots.push({ 
          time: `${hh}:${mm}`, 
          display: `${hh}:${mm} - ${nh}:${nm}`, 
          startM: cur,
          endM: next
      });
      cur = next;
    }
    return slots;
  }

  _normalizeDay(d){
    if(!d) return d;
    const lower = d.toLowerCase();
    const dayMap = {
        'lunes': 'Lunes',
        'martes': 'Martes', 
        'miercoles': 'Miercoles',
        'miércoles': 'Miercoles',
        'jueves': 'Jueves',
        'viernes': 'Viernes',
        'sabado': 'Sabado',
        'sábado': 'Sabado',
        'domingo': 'Domingo'
    };
    return dayMap[lower] || d;
  }

  _buildGrid(){
    this.grid.innerHTML = '';
    // corner
    this.grid.appendChild(this._celda('schedule-corner','Hora \\ Día'));
    // headers
    this.daysCanonical.forEach(d => this.grid.appendChild(this._celda('schedule-header', d)));
    // rows
    this.times.forEach(slot => {
      const claseHora = slot.time.endsWith(':00') ? 'schedule-time bold-hour' : 'schedule-time';
      this.grid.appendChild(this._celda(claseHora, slot.display));
      // cells per day with data attributes
      this.daysCanonical.forEach(day => {
        const cel = this._celda('schedule-cell','');
        cel.setAttribute('data-day', day);
        cel.setAttribute('data-time', slot.time);
        cel.setAttribute('data-start-min', slot.startM);
        cel.setAttribute('data-end-min', slot.endM);
        this.grid.appendChild(cel);
      });
    });
  }

  _celda(clase, text){
    const d = document.createElement('div');
    d.className = clase;
    d.textContent = text;
    return d;
  }

  _timeToMinutes(t){
    if(!t) return NaN;
    const parts = String(t).split(':').map(Number);
    if(parts.length >=2) return parts[0]*60 + parts[1];
    return NaN;
  }

  // carga inicial
  async _loadFromApi(){
    this._setStatus('Cargando horario...');
    try {
      const res = await fetch('/horario/api');
      if(!res.ok) throw new Error('HTTP ' + res.status);
      const data = await res.json();
      this._log('=== DATOS RECIBIDOS DEL API ===');
      this._log('Bloques recibidos:', data.bloques ? data.bloques.length : 0);
      this._log('Contenido:', JSON.stringify(data.bloques, null, 2));
      
      if(!data || !Array.isArray(data.bloques) || data.bloques.length===0){
        this._setStatus('No hay cursos en el horario');
        return;
      }

      this._renderBloques(data.bloques);
      this._setStatus(`Horario cargado (${data.bloques.length} cursos)`);
    } catch(e){
      console.error('Error al obtener horario', e);
      this._setStatus('Error de conexión con servidor');
    }
  }

  _setStatus(msg){ 
    const el = document.getElementById('statusMessage'); 
    if(el) el.textContent = msg; 
  }

  // Renderiza bloques
  _renderBloques(bloques){
    this._clearVisual();
    this._log('=== RENDERIZANDO BLOQUES ===');
    bloques.forEach((b, index) => {
      this._log(`Bloque ${index + 1}:`, JSON.stringify(b));
      this._renderBloque(b);
    });
  }

  _clearVisual(){
    this.grid.querySelectorAll('.course-block').forEach(n => n.remove());
    this.grid.querySelectorAll('.schedule-cell').forEach(c => { 
        c.innerHTML=''; 
        c.style.background = '';
    });
  }

  _renderBloque(b){
    const rawDay = b.dia || b.day || '';
    const dayNorm = this._normalizeDay(rawDay);
    
    this._log(`Procesando bloque: ${rawDay} -> ${dayNorm}`);
    this._log(`Horario: ${b.horaInicio} - ${b.horaFin}`);

    const startMin = this._timeToMinutes(this._shortenTime(b.horaInicio));
    const endMin = this._timeToMinutes(this._shortenTime(b.horaFin));
    
    this._log(`Tiempos en minutos: ${startMin} - ${endMin}`);

    if(isNaN(startMin) || isNaN(endMin) || endMin <= startMin) {
      this._log('ERROR: Horario inválido en bloque', b);
      return;
    }

    const selector = `.schedule-cell[data-day="${dayNorm}"]`;
    const dayCells = Array.from(this.grid.querySelectorAll(selector));
    
    this._log(`Celdas encontradas para ${dayNorm}: ${dayCells.length}`);

    if(dayCells.length === 0){
      this._log(`ERROR: No hay celdas para día ${dayNorm}`);
      return;
    }

    const cellsInRange = dayCells.filter(cell => {
      const cellStartMin = parseInt(cell.getAttribute('data-start-min'));
      const cellEndMin = parseInt(cell.getAttribute('data-end-min'));
      return cellStartMin < endMin && cellEndMin > startMin;
    });

    this._log(`Celdas en rango: ${cellsInRange.length}`);

    if(cellsInRange.length === 0){
      this._log('ERROR: Ninguna celda encontrada en el rango');
      return;
    }

    const blockEl = document.createElement('div');
    blockEl.className = 'course-block';

    const nombreCurso = b.nombreCurso || b.nombre || 'Curso';
    const docente = b.docente || 'Docente no especificado';
    const codigoSeccion = b.codigoSeccion || 'Código no disponible';
    const horaInicio = this._shortenTime(b.horaInicio);
    const horaFin = this._shortenTime(b.horaFin);

    blockEl.innerHTML = `
      <div class="course-title">${this._truncateText(nombreCurso, 40)}</div>
      <div class="course-info">${this._truncateText(docente, 35)}</div>
      <div class="course-info">Sección: ${codigoSeccion}</div>
      <div class="course-time">${horaInicio} - ${horaFin}</div>
    `;

    blockEl.title = `${nombreCurso}\nDocente: ${docente}\nSección: ${codigoSeccion}\nHorario: ${horaInicio} - ${horaFin}`;

    const firstCell = cellsInRange[0];
    const lastCell = cellsInRange[cellsInRange.length - 1];

    const top = firstCell.offsetTop;
    const left = firstCell.offsetLeft;
    const height = (lastCell.offsetTop + lastCell.offsetHeight) - firstCell.offsetTop;
    const width = firstCell.offsetWidth - 4;

    blockEl.style.position = 'absolute';
    blockEl.style.top = `${top}px`;
    blockEl.style.left = `${left}px`;
    blockEl.style.width = `${width}px`;
    blockEl.style.height = `${height}px`;

    this.grid.appendChild(blockEl);
    this._log(`✓ Bloque renderizado en ${dayNorm} ${horaInicio}-${horaFin}`);
  }

  _truncateText(text, maxLength) {
    if (text.length <= maxLength) return text;
    return text.substring(0, maxLength - 3) + '...';
  }

  _shortenTime(t){
    if(!t) return t;
    if(typeof t !== 'string') t = String(t);
    const parts = t.split(':');
    return parts.length >= 2 ? `${parts[0].padStart(2,'0')}:${parts[1].padStart(2,'0')}` : t;
  }

  async refresh(){
    await this._loadFromApi();
  }
}

let horarioManager = new HorarioManager();

function actualizarDesdeBackend(){ 
  horarioManager.refresh(); 
}

function limpiarHorario(){
  if(!confirm('¿Seguro que quieres limpiar todo el horario?')) return;
  fetch('/horario/api/clear', { method:'DELETE' })
    .then(r => {
      if(r.ok){
        horarioManager._clearVisual();
        document.getElementById('statusMessage').textContent = 'Horario limpiado';
      } else {
        alert('Error al limpiar horario');
      }
    }).catch(e => { 
      alert('Error al conectar con el servidor'); 
      console.error(e); 
    });
}

function toggleDebug() {
  const debugPanel = document.getElementById('debugPanel');
  debugPanel.style.display = debugPanel.style.display === 'none' ? 'block' : 'none';
}
</script>
</body>
</html>